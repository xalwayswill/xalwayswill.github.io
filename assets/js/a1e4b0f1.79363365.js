"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5263],{13682:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var s=t(74848),i=t(28453);const a={},o=void 0,r={id:"FPGA-IC/Verilog_X_Bugs",title:"Verilog_X_Bugs",description:"7 How To Avoid Dangerous X\u2019s",source:"@site/docs/FPGA-IC/Verilog_X_Bugs.md",sourceDirName:"FPGA-IC",slug:"/FPGA-IC/Verilog_X_Bugs",permalink:"/docs/FPGA-IC/Verilog_X_Bugs",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/FPGA-IC/Verilog_X_Bugs.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Valid-Ready\u6253\u62cd-TODO\uff1a\u81ea\u5df1\u6574\u7406\u4e0b",permalink:"/docs/FPGA-IC/Valid-Ready\u6253\u62cd-TODO\uff1a\u81ea\u5df1\u6574\u7406\u4e0b"},next:{title:"common-lib",permalink:"/docs/FPGA-IC/common-lib"}},l={},c=[{value:"7 How To Avoid Dangerous X\u2019s",id:"7-how-to-avoid-dangerous-xs",level:2},{value:"7.1 Good RTL Coding Practice",id:"71-good-rtl-coding-practice",level:3},{value:"7.2 Removing Reachable Don&#39;t-Care X-assignments",id:"72-removing-reachable-dont-care-x-assignments",level:3},{value:"7.3 Replacing X-Insertion with Assertions",id:"73-replacing-x-insertion-with-assertions",level:3},{value:"7.4 Enabling X-Propagation",id:"74-enabling-x-propagation",level:3},{value:"7.5 Avoiding Un-Initialized Registers",id:"75-avoiding-un-initialized-registers",level:3},{value:"7.6 Future: System Verilog and Verilog 2xxx",id:"76-future-system-verilog-and-verilog-2xxx",level:3},{value:"9 Top-Ten Recommendations",id:"9-top-ten-recommendations",level:2}];function d(e){const n={h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"7-how-to-avoid-dangerous-xs",children:"7 How To Avoid Dangerous X\u2019s"}),"\n",(0,s.jsx)(n.p,{children:"This section describes how to overcome problems related to X (after they have been identified and analyzed using\ntechniques described in section 6)."}),"\n",(0,s.jsx)(n.h3,{id:"71-good-rtl-coding-practice",children:"7.1 Good RTL Coding Practice"}),"\n",(0,s.jsx)(n.p,{children:"The unwanted affects of X semantics can be reduced by following some RTL coding guidelines, including:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["For if statements:\na) Never use if statements in combinatorial logic (use case or ternary ? instead), because if is X-optimism(interpretation of X will take just one if/case branch when many should be considered)\nb) Only use if statements for sequential elements (e.g. flip-flop with asynchronous reset)\nc) ",(0,s.jsx)(n.strong,{children:"Add X-checking assertions to a clock-gating enables in sequential logic"}),", e.g. if (enable)"]}),"\n",(0,s.jsx)(n.li,{children:"For casex and casez statements:\na) Never use casex (it\u2019s far too dangerous)\nb) Avoid casez if possible (Z-wildcard doesn\u2019t propagate X\u2019s and it\u2019s hard to translate to VHDL)"}),"\n",(0,s.jsx)(n.li,{children:"For case statements:\na) Always add a default line (to avoid X-Latching)\nb) Only use the default to assign X\u2019s (to avoid X-Optimism)\nc) Never use explicit X\u2019s in case-items\nd) Cover all reachable 2-state values with case-items\ne) Avoid using case for one-hot multiplexers on a critical path (use sum-of-products instead, Boolean Algebra)"}),"\n",(0,s.jsx)(n.li,{children:"Reduce the number of reachable X\u2019s:\na) Discourage the widespread use of X-assignments as synthesis don\u2019t-cares\nb) Consider pre-minimizing essential don\u2019t-care X\u2019s prior to RTL verification (see section 7.2)\nc) Avoid flip-flops that are not reset (only exception should be for large datapath registers)"}),"\n",(0,s.jsx)(n.li,{children:"Avoid synthesis/simulation specific workarounds that change semantics:\na) Never use full_case or parallel_case synthesis pragmas\nb) Avoid translate_off/on pragmas that change RTL simulations (e.g. for casez X-propagation)\nWhen you cannot follow these rules for any reason, e.g. complexity or legacy, use X-checking assertions and formal\nproperty checking to verify the RTL."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"72-removing-reachable-dont-care-x-assignments",children:"7.2 Removing Reachable Don't-Care X-assignments"}),"\n",(0,s.jsx)(n.h3,{id:"73-replacing-x-insertion-with-assertions",children:"7.3 Replacing X-Insertion with Assertions"}),"\n",(0,s.jsx)(n.p,{children:"You should never insert X\u2019s into your code to see if they cause problems. Instead, add assertions to your RTL to act\nas exception handlers \u2013 to raise an error for an unexpected event. Note that X\u2019s do not stress RTL simulations with\nboth possible values \u2013 instead, only one path will be evaluated!"}),"\n",(0,s.jsx)(n.h3,{id:"74-enabling-x-propagation",children:"7.4 Enabling X-Propagation"}),"\n",(0,s.jsx)(n.h3,{id:"75-avoiding-un-initialized-registers",children:"7.5 Avoiding Un-Initialized Registers"}),"\n",(0,s.jsx)(n.p,{children:"Where possible, reset your registers (this avoids X-initialization issues and helps to validate and formally verify your\ndesign). The exception is for large datapath registers, where the cost of routing a reset is not acceptable."}),"\n",(0,s.jsx)(n.h3,{id:"76-future-system-verilog-and-verilog-2xxx",children:"7.6 Future: System Verilog and Verilog 2xxx"}),"\n",(0,s.jsx)(n.p,{children:"The SystemVerilog language proposed by Accellera has lots of interesting features that could overcome problems\nassociated with X-semantics, including:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Several 2-state datatypes (e.g. bit, byte, int) that have defined semantics (as opposed to modes specific to a\nparticular simulator)."}),"\n",(0,s.jsx)(n.li,{children:"Qualifiers for selection (case/if) statements, called unique and priority, to clearly define their\nsemantics for both synthesis and simulation (unlike synthesis pragmas)."}),"\n",(0,s.jsx)(n.li,{children:"Assertions that are an intrinsic part of the design language itself, rather than an afterthought or a toolspecific assertion language or library."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"9-top-ten-recommendations",children:"9 Top-Ten Recommendations"}),"\n",(0,s.jsx)(n.p,{children:"This section reiterates the recommendations made throughout this document.\nRecommendation 1: Even if all RTL simulations pass, a don\u2019t-care should be considered to be a\ndon\u2019t-know unless it\u2019s proven to be unreachable.\nRecommendation 2: Always start an equivalence checker in the strict 2-State Equality comparison\nmode (the default settings of the tool can miss bugs).\nRecommendation 3: If a comparison fails with strict 2-State Equality but passes with 2-State\nConsistency, the pass is acceptable provided you can prove that all X\u2019s causing\ndifferences are unreachable (i.e. the failures are false negatives).\nRecommendation 4: RTL Verilog vs. translated RTL VHDL should be equivalence checked using 2-\nState Equality (to ensure that the don\u2019t-care space is identical).\nRecommendation 5: Never use casex statements as they are just too dangerous, and avoid casez\nwhenever possible.\nRecommendation 6: Use automatic property checking to prove that an X is unreachable, or interactive\nproperty checking to prove that the X is not stored in a register.\nRecommendation 7: Use automatic property checking to investigate code coverage reports.\nRecommendation 8: For one-hot logic on a critical path, write the RTL directly in a sum-of-products\nform (rather than case) and add a one-hot assertion checker.\nRecommendation 9: Avoid using if statements, as they optimistically interpret X\u2019s. Instead use\nternary (i.e. conditional ?) operators or priority-encoded case statements.\nRecommendation 10: For case statements, cover all reachable 2-state values with case-items and\nalways add a default (but only use it to assign X\u2019s, to avoid X-Optimism)"})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(96540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);