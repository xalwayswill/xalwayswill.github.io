"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1300],{85167:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>i,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var n=t(74848),c=t(28453);const s={},r=void 0,a={id:"work-log---g/SDC\u76f8\u5173",title:"SDC\u76f8\u5173",description:"How to perform timing check between asynchronous clock domains",source:"@site/docs/work-log---g/SDC\u76f8\u5173.md",sourceDirName:"work-log---g",slug:"/work-log---g/SDC\u76f8\u5173",permalink:"/docs/work-log---g/SDC\u76f8\u5173",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/work-log---g/SDC\u76f8\u5173.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\u9762\u79ef\u8bb0\u5f55",permalink:"/docs/work-log---arm-china/\u9762\u79ef\u8bb0\u5f55"},next:{title:"ptpx",permalink:"/docs/work-log---g/ptpx"}},i={},l=[{value:"How to perform timing check between asynchronous clock domains",id:"how-to-perform-timing-check-between-asynchronous-clock-domains",level:3},{value:"set_data_check",id:"set_data_check",level:3}];function h(e){const o={code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.h3,{id:"how-to-perform-timing-check-between-asynchronous-clock-domains",children:"How to perform timing check between asynchronous clock domains"}),"\n",(0,n.jsx)(o.p,{children:"If two clock domains are asynchronous and you have applied set_false_path between these two clocks, no timing checks can be performed. Also, if you have defined a clock group with asynchronous clocks using the set_clock_groups command with the -asynchronous option, by default the tool cannot perform a timing check. But if you use the -allow_paths option with the set_clock_groups command, timing check can be performed.\r\nTo control the data path delay between the registers from asynchronous clock domains:\r\nSpecify the asynchronous clock domains such that the timing check is possible. So, the asynchronous clock domains should be specified with the set_clock_groups constraint, not with the set_false_path constraint.\r\nSelect appropriate SDC constraints to restrict the combinational delay. So, the set_clock_groups constraint should be specified with the -asynchronous and -allow_paths options, as depicted in the following example:\r\nset_clock_groups -asynchronous -group [get_clocks clk1] -group [get_clocks clk2] -allow_paths\r\nAfter enabling timing check on the domain crossing paths, use the set_max_delay timing constraint with the -combinational_from_to option to specify the maximum delay allowed on this path segment."}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{children:"# Style 1: delay constraint using clock references\r\nset_max_delay -from [get_clocks clk1] -to [get_clocks clk2] -combinational_from_to\r\n\r\n# Style 2: delay constraint using references to registers at clock domain crossing\r\nset_max_delay -from <clock pin of source register FF1/CK> -to <data pin of destination register FF2/D> -combinational_from_to\n"})}),"\n",(0,n.jsx)(o.p,{children:(0,n.jsx)(o.strong,{children:"The -combinational_from_to option guarantees the following:"})}),"\n",(0,n.jsx)(o.p,{children:"Only the combinational path delay check is performed at the clock domain crossing.\r\nRemoves clock latencies from the delay computation.\r\nRemoves setup/hold constraint of the capture register from the delay computation.\r\nNote: Append the -path_exceptions all option to the report_timing command to diagnose the max delay constraint applied on the path"}),"\n",(0,n.jsx)(o.p,{children:(0,n.jsx)(o.strong,{children:"To summarize:"})}),"\n",(0,n.jsx)(o.p,{children:"Use set_clock_groups -asynchronous -allow_paths for asynchronous clock specification.\r\nUse set_max_delay -combinational_from_to for path delay specification."}),"\n",(0,n.jsx)(o.h3,{id:"set_data_check",children:"set_data_check"}),"\n",(0,n.jsx)(o.p,{children:"Setup and hold checks can also be applied between any two arbitrary data Pins, neither of which is a clock.\r\nDistinction with respect to the setup check\uff1a"}),"\n",(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsxs)(o.li,{children:["The data to data setup check is performed on ",(0,n.jsx)(o.strong,{children:"the same edge"})," as the ",(0,n.jsx)(o.strong,{children:"launch"})," edge"]}),"\n",(0,n.jsx)(o.li,{children:"Unlike a normal setup check of a flip-flop, where the capture clock edge is normally one cycle away from the launch clock edge"}),"\n"]})]})}function d(e={}){const{wrapper:o}={...(0,c.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},28453:(e,o,t)=>{t.d(o,{R:()=>r,x:()=>a});var n=t(96540);const c={},s=n.createContext(c);function r(e){const o=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function a(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),n.createElement(s.Provider,{value:o},e.children)}}}]);