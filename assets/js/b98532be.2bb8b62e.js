"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9521],{86044:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>a});var i=n(74848),o=n(28453);const s={},l=void 0,r={id:"FPGA-IC/\u539f\u578b\u9a8c\u8bc1(Prototyping)",title:"\u539f\u578b\u9a8c\u8bc1(Prototyping)",description:"### Converting ASIC Designs for FPGA Prototyping",source:"@site/docs/FPGA-IC/\u539f\u578b\u9a8c\u8bc1(Prototyping).md",sourceDirName:"FPGA-IC",slug:"/FPGA-IC/\u539f\u578b\u9a8c\u8bc1(Prototyping)",permalink:"/docs/FPGA-IC/\u539f\u578b\u9a8c\u8bc1(Prototyping)",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/FPGA-IC/\u539f\u578b\u9a8c\u8bc1(Prototyping).md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\u4f4e\u529f\u8017\u76f8\u5173",permalink:"/docs/FPGA-IC/\u4f4e\u529f\u8017\u76f8\u5173"},next:{title:"\u53cc\u8c03\u6392\u5e8fBitonic-Sort",permalink:"/docs/FPGA-IC/\u53cc\u8c03\u6392\u5e8fBitonic-Sort"}},c={},a=[{value:"Converting ASIC Designs for FPGA Prototyping",id:"converting-asic-designs-for-fpga-prototyping",level:3},{value:"General Guidelines for Prototyping The following guidelines describe some of the best practices to follow with ASIC designs that are to be prototyped in FPGAs:",id:"general-guidelines-for-prototyping-the-following-guidelines-describe-some-of-the-best-practices-to-follow-with-asic-designs-that-are-to-be-prototyped-in-fpgas",level:3},{value:"General Guidelines for Prototyping",id:"general-guidelines-for-prototyping",level:3},{value:"Identifying FPGA-Hostile RTL",id:"identifying-fpga-hostile-rtl",level:3},{value:"Converting SoC Constructs",id:"converting-soc-constructs",level:3},{value:"Converting Memories",id:"converting-memories",level:3},{value:"Converting Clocks",id:"converting-clocks",level:3},{value:"Clock Generation",id:"clock-generation",level:4},{value:"Clock Distribution",id:"clock-distribution",level:4},{value:"Gated Clocks",id:"gated-clocks",level:4}];function d(e){const t={blockquote:"blockquote",h3:"h3",h4:"h4",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.h3,{id:"converting-asic-designs-for-fpga-prototyping",children:"Converting ASIC Designs for FPGA Prototyping"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Before an ASIC SoC design can be mapped to an FPGA, some parts of the design must be replaced or reworked because of architectural differences\r\nbetween FPGAs and ASICs. These are some typical issues that must be addressed:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"ASIC gated clock and generated clock structures do not fit on the FPGA."}),"\n",(0,i.jsx)(t.li,{children:"Internal fix clock sources and PLLs must be replaced."}),"\n",(0,i.jsx)(t.li,{children:"ASIC memories cannot be used on the FPGA. You can replace simple memories with FPGA equivalents generated with dedicated tools from\r\nFPGA vendors. For more complex memories, you must write replacement models for the FPGA."}),"\n",(0,i.jsx)(t.li,{children:"Latches and asynchronous delays must be reworked or replaced."}),"\n",(0,i.jsx)(t.li,{children:"ASIC analog modules require wrappers before they can be used on the FPGA."}),"\n",(0,i.jsx)(t.li,{children:"I/O control logic for dedicated boards"}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.h3,{id:"general-guidelines-for-prototyping-the-following-guidelines-describe-some-of-the-best-practices-to-follow-with-asic-designs-that-are-to-be-prototyped-in-fpgas",children:"General Guidelines for Prototyping The following guidelines describe some of the best practices to follow with ASIC designs that are to be prototyped in FPGAs:"}),"\n"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Avoid latches because they are hard to time on an FPGA. \u2022 Avoid combinational loops."}),"\n",(0,i.jsx)(t.li,{children:"To keep the RTL portable, do not include optimizations like clock gating, test insertion, and low-power in the RTL. Leave optimizations to the SoC tools and keep the RTL pure as far as possible."}),"\n",(0,i.jsx)(t.li,{children:"Use \u2018define and \u2018ifdef to include or remove prototyping edits. Use these constructs to isolate BIST (built-in self test), memory instantiations, etc."}),"\n",(0,i.jsx)(t.li,{children:"Isolate RTL changes to within the library elements rather than outside them in the RTL structure. This improves portability and keeps the prototyping code as close to the original as possible."}),"\n",(0,i.jsx)(t.li,{children:"Share make files between SoCs and FPGAs by using macro-driven branching for different targets."}),"\n",(0,i.jsx)(t.li,{children:"Keep source changes low-impact by using wrappers to make changes. Replace files instead of editing them, and backannotate all changes."}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.h3,{id:"general-guidelines-for-prototyping",children:"General Guidelines for Prototyping"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The following guidelines describe some of the best practices to follow with ASIC designs that are to be prototyped in FPGAs:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Avoid latches because they are hard to time on an FPGA."}),"\n",(0,i.jsx)(t.li,{children:"Avoid combinational loops."}),"\n",(0,i.jsx)(t.li,{children:"To keep the RTL portable, do not include optimizations like clock gating, test insertion, and low-power in the RTL. Leave optimizations to the SoC\r\ntools and keep the RTL pure as far as possible."}),"\n",(0,i.jsx)(t.li,{children:"Use \u2018define and \u2018ifdef to include or remove prototyping edits. Use these constructs to isolate BIST (built-in self test), memory instantiations, etc."}),"\n",(0,i.jsx)(t.li,{children:"Isolate RTL changes to within the library elements rather than outside them in the RTL structure. This improves portability and keeps the prototyping code as close to the original as possible."}),"\n",(0,i.jsx)(t.li,{children:"Share make files between SoCs and FPGAs by using macro-driven branching for different targets."}),"\n",(0,i.jsx)(t.li,{children:"Keep source changes low-impact by using wrappers to make changes. Replace files instead of editing them, and backannotate all changes."}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.h3,{id:"identifying-fpga-hostile-rtl",children:"Identifying FPGA-Hostile RTL"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The following ASIC structures do not easily map to FPGA architectures:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Asynchronous logic, latches, block inferences"}),"\n",(0,i.jsx)(t.li,{children:"ASIC memory is too big and must be split across multiple RAMs"}),"\n",(0,i.jsx)(t.li,{children:"Clocks with gating"}),"\n",(0,i.jsx)(t.li,{children:"Clock muxing, for embedded test logic, for example"}),"\n",(0,i.jsx)(t.li,{children:"Top-level pads"}),"\n",(0,i.jsx)(t.li,{children:"Gate-level netlists"}),"\n",(0,i.jsx)(t.li,{children:"SoC leaf cells instantiations"}),"\n",(0,i.jsx)(t.li,{children:"SoC memories"}),"\n",(0,i.jsx)(t.li,{children:"SoC-specific IP without RTL"}),"\n",(0,i.jsx)(t.li,{children:"BIST instantiated in the RTL"}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.h3,{id:"converting-soc-constructs",children:"Converting SoC Constructs"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The following ASIC components are FPGA-hostile, and must be converted for\r\nFPGA design:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Top-level pads"}),"\n",(0,i.jsx)(t.li,{children:"Gate-level netlists"}),"\n",(0,i.jsx)(t.li,{children:"Leaf cell instantiations in the RTL"}),"\n",(0,i.jsx)(t.li,{children:"SoC memories"}),"\n",(0,i.jsx)(t.li,{children:"SoC-specific IP, if the source RTL is not available"}),"\n",(0,i.jsx)(t.li,{children:"BIST and other test circuitry. Handle them by leaving these signals dangling."}),"\n",(0,i.jsx)(t.li,{children:"Gated clocks generally overflow the FPGA clock resources"}),"\n",(0,i.jsx)(t.li,{children:"Complex generated clocks need to be simplified to fit the FPGA resources"}),"\n",(0,i.jsx)(t.li,{children:"Asynchronous delays in latches need to be removed, reworked or replaced. Replace by clocked processes"}),"\n",(0,i.jsx)(t.li,{children:"Analog modules need wrappers to interface to external circuitry"}),"\n",(0,i.jsx)(t.li,{children:"Clock sources--fix clock source, replace PLL"}),"\n"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.h3,{id:"converting-memories",children:"Converting Memories"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"ASIC memory is typically too large for FPGA memory structures. Complex memories must be mapped to FPGA models; less complex ones can be directly replaced by memories generated by tools like Intel FPGA MegaWizard."}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.h3,{id:"converting-clocks",children:"Converting Clocks"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"ASIC clocks are typically quite complex, with numerous clocks that are \u201cbalanced\u201d in the design through clock tree synthesis. Even though prototyping is done before clock tree synthesis, the clocking scheme in the RTL might still be too sophisticated for an FPGA and must be simplified before the design can be prototyped as an FPGA.\r\nUnlike ASICs, FPGAs have a finite number of balanced clock resources that are part of the architecture. A gated clock adds extra delay and upsets the balance, introducing timing violations and other glitches in the process."}),"\n",(0,i.jsx)(t.h4,{id:"clock-generation",children:"Clock Generation"}),"\n",(0,i.jsx)(t.p,{children:"To generate FPGA clock equivalents, instantiate any features that are not inferred using the architectural features available in the target architecture, such as clock managers and programmable clock generators such as phase-locked loops (PLLs).\r\nWhen possible suppress clock muxes. If they cannot be removed or reworked, modify the constraints and declare the clock at the mux output."}),"\n",(0,i.jsx)(t.h4,{id:"clock-distribution",children:"Clock Distribution"}),"\n",(0,i.jsx)(t.p,{children:"The synthesis tools automatically map global clocks to the global clocking resources on the FPGA. Use attributes to specify regional clocks."}),"\n",(0,i.jsx)(t.h4,{id:"gated-clocks",children:"Gated Clocks"}),"\n",(0,i.jsx)(t.p,{children:"FPGAs have dedicated low-skew clock distribution nets and un-gated clocks, but SoC designs use gated clocks. To make it possible to use the same RTL for both SoC and FPGA designs, the Synplify Elite tool provides the functionality to automate the translation. The functionality moves the SoC clock gating from the clock pins of sequential elements to the enable pins. This provides a logically-equivalent FPGA version, without altering the original RTL."})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>r});var i=n(96540);const o={},s=i.createContext(o);function l(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);