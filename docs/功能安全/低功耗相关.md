# 减低功耗的优点
1） 功耗过大会缩短使用时间，常用手机等电子设备的我们也知道，频繁充电会大大降低我们的用户体验。

2） 功耗过大会造成更高的温度，较高的温度会引起电子迁移或者其他的热失效机制，从而降低芯片的稳定性。

3） 对于汽车而言，自动驾驶芯片的功耗超过一定限度，则会需要车厂采用水冷措施来降温而不是风冷系统，这也会提高整车的制造成本。

4） 功耗大也会影响电池寿命，使电池寿命更短，这也从一定程度上提高了用户的成本及降低了用户的产品体验。

所以片上系统的功耗是一个非常重要的话题，作为芯片设计方，使搭载到智能汽车的自动驾驶芯片拥有更低的功耗贯穿了我们工作的始终，从前期芯片非自研IP选型，到中期芯片设计，到后期的软件及解决方案，我们将从每个阶段尽量降低芯片的功耗，在保证算力的同时提供更稳定更具市场竞争力的自动驾驶芯片。

# 降低功耗的方式
## 基本概念
首先要介绍两个概念：动态功耗和静态功耗。SoC的功耗包括动态功耗（Dynamic Power）和静态功耗（Static Power）。
* 动态功耗

动态功耗是因为信号值改变带来的功耗损失。动态功耗由两部分组成：开关功耗（switching power）和内部功耗（internal power）。开关功耗是外部电容充放电消耗的功率（如图1所示），内部功耗是电路逻辑状态变化时流过PMOS-NMOS堆的短路电流消耗的功率（如图2所示）。
![](低功耗相关.assets\23495115-5a17dadaca8f81b2.png)
![](低功耗相关.assets\23495115-68dfa1858db0e1b0.png)
* 静态功耗（Static Power）

静态功耗是设备还在上电状态但是没有信号值改变时消耗的功率。在CMOS设备中，静态功耗来源于漏电（如图3所示）。
![](低功耗相关.assets\23495115-825173249dbf4686.png)
## 降低功耗的方式
### 降低供电电压（Supply Voltage Reduction）

最基础的降低功耗的方式是降低供电电压。功耗与电压的平方成正比。所以如果降低50%的电压，功耗会降低75%（如图4所示）。CMOS技术的不断更新迭代使供电电压越来越低以降低功耗，供电电压从上世纪八十年代的5V降低到当前0.75V甚至更低。

![](低功耗相关.assets\23495115-5dbae7fe2a2af5ac.png)




### 时钟门控（Clock Gating）

时钟门控（clock gating）是一种降低动态功耗的方式。对于那些很多个时钟周期下都需要保持同一个数值的寄存器来说，这种降低功耗的方式非常有用，因为这种方式可避免每个时钟周期都重新加载寄存器而带来的不必要的功耗损失。这个方法最大的挑战是如何找到最优的位置来放置时钟门控，以保证在合适的时间开关时钟。

时钟门控技术沿用了多年，也很成熟。Power Compiler等综合工具可以监测到低吞吐量的数据路径，然后在时钟路径上合适的位置自动插入时钟门控单元。时钟门控的实现也比较简单，它只需要改网表，而不需要额外增加电源供电或者其它电源设施。


### 多Vt库单元（Multiple-Vt Library Cells）


一些CMOS技术支持具有不同电压阈值的标准库单元。在这种情况下，单元库可以提供两种甚至更多不同的阈值电压单元来实现相同的逻辑功能。举个例子：库里可以提供两种反相器单元：一种是low-Vt晶体管，一种是high-Vt晶体管。

Low-Vt单元有更高的速度，但是同时拥有更大的漏电流。High-Vt单元有更低的漏电流，但是速度更慢。所以综合工具可以根据速度和功耗的tradeoff来选择合适类型的单元。比如可以用low-Vt单元在timing-critical的路径以达到更高的速度，至于对timing要求不是很高的路径可选用high-Vt单元以减少功耗。

### 多电压设计（Multi-voltage Design）

芯片不同的部分有不同的速度需求。比如CPU和RAM需要比外设拥有更高的速度。就像前面提到的，低电压不仅会降低功耗也会降低速度。为了得到最大的速度和更低的功耗，可以给CPU和RAM提供较高的供电电压，而给外设部分提供较低的供电电压。但是在同一个芯片上提供两个或多个供电会增加设计复杂性和成本。比如需要更多的管脚来给芯片供电，而且电源网格必须将每个电压源分别分配给适当的模块。

### 电源开关（Power Switching）

电源开关是在芯片的某个模块长时间不用的情况下，通过关掉电源的方式来节省功耗的一种方式。比如一个手机芯片，当手机处于待机模式的时候关掉声音处理模块。当用户收到电话或者打电话的时候，这个模块会被唤醒。

电源开关进一步降低了静态功耗和动态功耗。但是它也带来了一些挑战，比如它的实现需要一个电源控制器，一个电源开关网络，隔离单元（isolation cells）和retention寄存器。

电源控制器就是一个决定什么时候上下电的逻辑模块。但是上电和下电会带来一定的时间和功耗代价，所以控制器必须决定一个合适的时间来开关电源。

一个可以被下电的模块必须从电源开关网络中收到供电，电源网络由大量在always-on的电源轨道和供电引脚单元之间有source-to-drain连接的晶体管组成。电源开关必须在该模块周围或者内部。这个网络，当打开电源时，连接了电源和逻辑门，当关上电源时，电源供电就从逻辑门断开连接。

我们常常会把High-Vt晶体管用作电源开关（power switch），因为它可以有更小的漏电流并且我们也不关心它的开关速度。如图5所示，PMOS header 开关可以被放在VDD和模块供电电源管脚中间，或者NMOS footer 开关可以被放在VSS和模块地管脚中间。
![](低功耗相关.assets\23495115-773ae74c9bd0c625.png)


上面描述的电源开关策略是粗粒度的开关策略，因为这个电源开关可以控制整个模块的上下电。如果是细粒度策略，则每个库单元都有自己的电源开关，允许更细粒度的控制电源上下电。这种方式可以更好的节省功耗，但是也要求更大的面积。

### 动态电压频率调整（Dynamic Voltage Frequency Scaling）


根据前面提到的多电压（Multi-voltage）的概念，我们可以将其拓展成操作过程中根据当前的工作负载而动态调整电压。比如一个芯片在做简单的计算时可以用更低的电压和更低的频率，如果需要更高的性能，则可以提高电压和频率。这种实时调整电压和频率的方式叫做DVFS。

芯片的供电电压可以被设计为多个档位或者一个连续的范围，动态调压要求多档位的供电及一个能准确判断给定任务的最优电压值的逻辑模块。因为要分析和考虑到不同的电压等级和频率的结合，所以这对设计、执行、验证和测试来说都是不小的挑战。

我们可以将动态调压和电源开关结合起来，让模块既可以根据当前工作负载调整电压也可以在完全不用的时候关掉电源，以达到更多的功耗节省。

# 功耗管理模块
随着当代SoC的复杂程度的提高，越来越多的芯片设计者选择将SoC中的功耗管理的角色独立出来，选择一个小的处理器结合软件来负责整个SoC的功耗管理。



以前是用操作系统（OS）来管理SoC的功耗和性能，但是慢慢发现形成和维护一个通用的OS kernel来支持不同供应商非常困难，且现在的SoC也有越来越多的限制，也迫使有能多的功能安全和信息安全的要求，这些对OS来说都过于复杂以至于无法在管理的同时满足最优负载性能。这就迫使工业界把基于OS的集中的控制机制剥离出来，形成一个专门用来控制和管理功耗和性能的小系统。

前面提到动态调压调频（DVFS）， DVFS会根据OS的工作负载选择\{频率，电压\}对，这就要求OS kernel要知道该平台支持的所有的\{频率，电压\}对的信息，然后还要知道如何读取和设置它们。每个SoC的读取和设置信息对的方式不同，所以如果需要OS kernel来管理功耗和性能，就需要根据每个SoC的设计更改kernel，这个与大家想保持kernel的通用性的想法相悖。因此，我们可以将平台支持的\{频率，电压\}对记录在功耗管理小系统中，并将性能等级与频率电压对进行一一对应，OS kernel仅需发出调整频率电压请求给小系统，小系统便可根据请求对频率和电压进行相应的调整。这样做既达到了控制的效果，也维护了OS kernel的通用性。

在功能安全方面，当出现偶发事件时，通常来说硬件的反应时间小于固件的反应时间小于内核Kernel的反应时间。图6展示了典型场景下，硬件hardware、固件firmware、OS Kernel对SoC平台偶发事件的反应时间。从图6可以看出，kernel的反应时间远大于固件的反应时间。而且，Kernel也无法知道SoC上所有功能安全相关的操作，所以这些事情也可以委派给到功耗控制小系统。该小系统有更快的反应时间且可以提供功能安全的保证，也可以享有控制SoC内其他的硬件的权力。
![](低功耗相关.assets\23495115-c49c6ec1ac105ca3.png)


此外，在信息安全方面，OS的DVFS实现在kernel，kernel位于BL1，而BL1是不可信（untrusted）的。如果kernel拥有频率和电压的控制权是比较危险的。不可信的软件可能会把SoC平台置于overclocked或者undervolted的状态。所以我们把对频率和电压的控制权转交给一个可信的firmware，这个firmware可以对要求的性能等级进行可信度检查，以避免恶意编程带来的危害。
# 系统低功耗模式及设计
ACPI[3]定义了G0~G3四种电源状态，G0是工作状态，G3是关电状态。G1和G2又分出了S0ix到S5的睡眠状态，且定义了每种睡眠状态下CPU，GPU及memory等模块的状态（如表1所示）。
![](低功耗相关.assets\23495115-076455b4d0e6a3b6.png)


对于SoC而言，首先需要支持工作和关电两种电源状态，然而介于这两种状态之间的睡眠态是应用场景需求决定的。当前汽车行业仍处于一个发展阶段，对于自动驾驶芯片的功耗模式定义尚未形成较固定的方案。根据当前自动驾驶芯片串联座舱芯片的场景来分析，现在很多汽车会支持前装哨兵模式，该模式则需要在汽车熄火且人离开汽车后，汽车上的传感器可以感知物体靠近来唤醒车身上的摄像头。唤醒摄像头意味着控制其的芯片也需被唤醒，使其将周围发生的情况通过摄像头记录并保存下来。然而，如果该功能下自动驾驶芯片完全关电，唤醒时芯片从上电到可以工作的时间可能要10秒以上，这是无法满足场景需求的。所以这就要求在该模式下自动驾驶芯片支持一个快速唤醒的低功耗状态。为什么需要一个低功耗状态？因为如果还保持之前的工作状态，芯片的耗电量会比较大，从而造成车机很快没电，非常影响用户体验及电池寿命。所以前装哨兵模式需要自动驾驶芯片必须支持至少一种低功耗模式。

此外，一些车厂可选择汽车熄火后不完全给自动驾驶芯片和座舱芯片关电，而是选择让它们处于一种超低功耗的模式。这样做带来的好处是一旦点火，车机系统可以非常快的启动到离开车前的状态。一般座舱芯片会采用Android系统，Android系统的启动可能需要十秒以上的时间，也就是说用户从启动汽车到看到显示屏显示可能需要十几秒甚至更久的时间，这会大大降低用户的产品体验。低功耗模式可以将下电前的软件现场保存在DDR连接的DRAM颗粒中，并使DRAM颗粒处于一种retention状态，且仅保持一个耗电量很小的处理器小系统在工作。这个小处理器在收到唤醒信号后，可以将现场快速恢复到车机系统到离车前状态。这个状态耗电量很小，且可以快速唤醒，可以在耗费很小电量的同时解决因操作系统启动较慢而造成的不良体验的问题。这种功能也需要自动驾驶芯片支持低功耗模式。
## 系统低功耗模式设计
### 电源域
首先要介绍一下电源域概念，电源域是指同一个电压域内，共享相同电源开关逻辑的模块合集。前面有提到，多电压设计是降低功耗的一种方式，不同的电压就会是不同的电源域。对于现在功能比较复杂的SoC而言，多电源域设计是必须的选择。
### 基于多电源域的低功耗模式设计
前面提到自动驾驶芯片的应用场景，如果要支持低功耗模式，如何降低功耗？整体思路就是要把该模式下不需要用到的模块做关电处理，以节省动态功耗和静态功耗。而对于无法做关电处理的模块，我们保留其供电，但是在供电状态下，选择该模块的低功耗模式以达到最多的功耗节省。比如memory，我们需要用到连接到LPDDR的DRAM颗粒保存软件栈现场的信息，RAM的特性是一旦下电，数据就会消失，所以我们会采用保存其数据不消失但最省电的一种功耗模式-Retention模式。之前我们还提到，SoC的功耗管理模块是一个以一个处理器为核心的小系统，所以该场景下需要该处理器保持运行，以监测外界的唤醒信息及帮助其他处理器核快速恢复现场。之前介绍了电源域，电源域中通常会有一个常电（Always-On）电源域，该电源域享有最高的电源等级，即在所有电源域中它掉电的优先级最低。低功耗模式下，该处理器要在上电状态，所以该处理器处于Always On电源域。处理器要运行，还需要内存来及时读写变量，所以该处理器要使用的SRAM也是在电状态。此外，还要有GPIO作为接收唤醒中断信息的源头，该GPIO收到唤醒中断信息并将其传给处理器，处理器接收到唤醒中断后启动其恢复现场程序。所以总的来说，该低功耗模式下需要一个管理功耗的子系统处于运行状态和DRAM颗粒处于Retention模式，其中子系统应包括一个处理器核，一块运行程序的内存，用于接收唤醒信号的GPIO，用于与PMIC通信的接口，及用于联通各个子模块的内部总线等。这样的一个功耗管理小系统加DRAM颗粒retention状态的设计即可满足在耗电量极低的情况下快速唤醒整片SoC的需求。示意图如图7，其中亮黄色为功耗管理小系统，处于Always-On电源域。除此之外，有一路供电给到DDR PHY以保持DRAM的Retention状态。
![](低功耗相关.assets\23495115-e012dc926f1e6dd5.png)

#引用

[1] Synopsys® Low-Power Flow User Guide Version B-2008.09, September 2008

[2] Power and Performance Management using Arm® SCMI Specification

[3] https://en.wikipedia.org/wiki/ACPI
