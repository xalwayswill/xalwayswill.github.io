1. 算法寄存器是signed类型时，验证环境给到 cmodel和RTL的寄存器值不一致
验证环境配置到RTL后按照补码运算可以获取到负值，但是cmodel如果按照int类型读取系数可能按照正数处理，需要在验证环境中进行转化。
2. 在算法计算位宽较大的时候需要考虑int类型的溢出问题
不同的编译器对于数据类型的转换方式不同，例如
```
long long c;
int a,b;
c = a * b
// c = static_cast<long long>(a) *  static_cast<long long>(b)
```
两个int类型相乘赋值给 long long 可能不会正确转换，= 右侧计算结果已经溢出，再赋值给c可能也不会得到正确的计算结果（visual studio code下似乎能够正常转换为long long，而 gcc 7.6 相乘的结果仍然是int类型），从而导致RTL与cmodel比对错误，这种溢出错误是很难发现的。
解决方法：
* 算法对于所有有可能溢出的运算左右操作数都先进行类型转换后再操作，如上面代码注释部分，避免溢出
* 算法直接编译出可执行文件给验证使用，同时在仿真环境下进行可执行文件与源代码的一致性测试，保证不会因为环境而出现结果溢出问题
