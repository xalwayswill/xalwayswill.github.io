转载https://zhuanlan.zhihu.com/p/62844487
不论是图像灰度直方图还是梯度直方图，本质上是对数据的分布进行计数。从FPGA角度来看，只关心以下几点：

1） 根据数据大小确定其分布区间，统计分布在不同区间的数据个数，区间的大小可以调节，比如灰度直方图区间为1，梯度直方图通常大于1；

2） 如何利用FPGA对直方图统计进行加速，以及如何考虑到芯片有限资源；

首先来考虑加速方式，直方图统计过程用伪代码表示为：

Get_index函数是为了确定数据属于哪个区间，如果区间大小为1，那么index就是数据自身。如果区间是平均分布，那么就需要进行数据的大小比较。如果区间大小是2的幂次，那么index只需要数据进行移位得到。

FPGA在加速计算中最主要就是利用并行化和流水线，并行化就是将一个任务拆解成多个子任务，多个子任务并行完成。而流水线是在处理一个子任务的时候，下一个来的子任务也可以进行处理，处理模块不会等待。流水线本质上是对子任务也进行“分割”，分割的每一块可以在处理模块中同时进行。

统计N个数据，可以将N分成M份，在FPGA上同时进行M个统计，用伪代码表示为：

如果区间不是2的幂次，就需要比较器，这样并行M次，就需要M个同等比较器，这对资源消耗很大。因此目前设计仅仅支持2的幂次的区间。整个设计架构如图1.2。

![](直方图统计.assets\23495115-bc1f24626077de03.jpg)

*图2.1 流水线处理*

![](直方图统计.assets\23495115-816834c333d834ee.jpg)

*图2.2 直方图统计架构*

主要分为以下几个模块：

1）statis:这个是核心计算模块，统计数据分布。ram中存放直方图统计数据，地址对应着数据分布区间。这里有一个问题需要考虑，在对ram中直方图统计数据计数时，需要读出然后计数。如果ram读端口没有寄存器，那么读出来直接加1，再写入。但是这样并不好，因为ram不经过寄存器时序不好。所以增加了一级寄存器，这样就造成了写入的延时，那么有可能下一次数据来临也会读取同样地址的数据，此时读取到的直方图数据就是还没有写入的。为了解决这个问题，判断进入的前后两个数据是否相同，如果相同就不写入而继续计数，如果不同就写入。

2）serders：这个是并转串。M个statis模块会产生M组hist结果，这些结果还要进行求和，那么就要用到加法树，如果M较大，会造成加法树很大，多以这里加了serders可以调节加法树资源。

3） addTree：加法树。

4） accum：累加器。如果加法树没有完成M个hist数据的求和，那么就需要通过累加器来完成。

![](直方图统计.assets\23495115-cc1f091c68924c58.jpg)

*图2.3 对ram的处理*
