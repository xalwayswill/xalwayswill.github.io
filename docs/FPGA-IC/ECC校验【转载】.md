## Reference
#### [十八般武艺-安全机制系列之ECC](https://aijishu.com/a/1060000000336469)
#### “A Class of Optimal minimum Odd-weight-column SEC-DED Codes”
####《算法心得 高效算法的奥秘 Chapter15》

需要明确ECC校验和差错控制编码的区别，ECC是由奇偶校验码演变而来的
## **前言**

对于内存的失效模式分为两类：

**①.内容损坏**，一般通过ECC来诊断。ECC可以由硬件实现，可以由软件实现。

**②.非法读写**，一般通过内存管理机制来实现，但需要支持MPU或MMU的硬件来配合实现。

对于**ECC**，相信大部分朋友都知道，能够纠正单bit故障，探测多bit故障。我在最初看到这部分内容的时候充满了困惑：

双冗余是没法纠正故障的，要达到纠正故障的效果得**多路表决**，ECC这个机制为探测内存故障付出了三倍冗余的代价吗？但一般存储或通信的冗余数据比原始数据要小啊，它是怎么以较小的数据做到纠正错误的呢？ 

## **ECC前任奇偶校验**

下面我们就一步步来走进神奇的ECC。

对于内存，当操作时序和电路稳定性正常时，一般不会造成整个存储单元不能读取或者全部出错，而是整个存储单元只有一个或几个比特出错，比如常见的由封装衰变的α粒子或者中子等引起的软错误影响范围局限于几个比特。

在ECC技术出现之前，内存中应用最多的就是“奇偶校验”。不带“奇偶校验”的内存中的每个字节（byte）只有8位，若它的某一位存储出了错误，就会使其中存储的相应数据发生改变而导致应用程序发生错误。而带有“奇偶校验”的内存在每一字节（8位）外又额外增加了一位用来进行错误检测，用它使这组代码中“1”的个数为奇数（奇校验）或偶数（偶校验）。

![](ECC校验【转载】.assets\23495115-b985dd5ee66efad4.png)


但奇偶校验存在明显的不足—**无法修正错误**：只知道8比特中有部分比特发生错误，无法判断哪个比特。

## **单比特修正**

要进行单比特修正，首先要解决两个问题：

①.到底是**原始数据故障**还是**校验位故障**

②.如果是原始数据位故障，到底是哪一位发生故障。

我们先思考②，**要定位8bit中哪一个bit发生了故障，需要多少bit的校验位呢？**

单bit错误有8+1种情况（无单bit错误），因而至少需要log29=4个校验位来进行定位，可以设计如下：

![](ECC校验【转载】.assets\23495115-ba6f25a23fab8a6a.png)


当Bit2翻转时，CP0、CP1、CP3发生变化，但Bit1发生翻转时，CP3发生变化。这样，**通过CPx的不同组合，就可以定位哪一位发生了故障。**

## **多路表决**

但这样没解决问题1，例如，根据原始数据计算出的CP3/CP2和自带的CP3/CP2不一致时，无法确认是原始数据Bit1/Bit5故障还是校验数据故障。

此时，我们来个**“多路表决”**，设计如下：

![](ECC校验【转载】.assets\23495115-082e4ad7c8599134.png)

此时，当bit5发生翻转时，将带来CP1, CP2, CP5翻转。此时，就解决了两个问题：

**①.区分原始数据故障还是校验数据故障**：原始数据故障，将导致3个CPx发生变化；校验数据故障，单个CPx发生变化；

**②.定位原始数据哪个bit发生故障**：通过CPx的特定组合实现。将原始数据区从1行扩展到多行，针对单bit故障，不增加校验位，同样可定位故障发生列。

以一个2kb的带ECC的EEPROM为例，Page分为Main和Spare区，如图4所示。Main是用来保存数据的。Spare区一般用来标记坏块和保存对Main区数据的ECC校验码。

![](ECC校验【转载】.assets\23495115-84feefdf8ff15f2a.png)

## **ECC校验**

我们可以用上面的思路来进行校验位的设计。在具体的诊断实践中，一般是**针对256 字节数据（256*8的矩阵）做ECC校验，生成6个比特的列校验数据，16个 (即) 比特的行校验数据。**其他两位用1补足，共3字节的校验数据，存在于OOB (Out Of Band) 区内，如图5所示。

![](ECC校验【转载】.assets\23495115-697df589e61859fb.png)

**其中CP0~CP5为6个比特位，表示Column Parity（列极性）。**每一个列极性为4列共1024位的异或结果，如CP0为第0、2、4、6列的异或结果。

**其中RP0~RP15为16个比特位，表示Row Parity（行极性）。**每一个行极性为128行共1024位的异或结果，如RP0位第0、2、4、6、…、252、254字节的异或结果。

故障定位分两步：**列定位和行定位**，以简单的列定位为例，将256行简化为2行，假设待校验的数据为2个字节，0x45（二进制为0100 0101）和0x38（二进制为0011 1000），其列校验码如下表5-10所示：

![](ECC校验【转载】.assets\23495115-4d63664d82f89897.png)


从表1可以计算出CP5~CP0的值，列在表2的第1行（原始数据）。

假设现在有一个数据位发生变化，0x38变为0x3A，也就是Byte1的Bit1由0变成了1，计算得到新的CP5~CP0值放在表5-11第2行（变化后数据）。

新旧校验码求异或的结果放在表5-11第3行。**可见，当Bit1发生变化时，将引起相关联的列校验值中的CP1、CP2、CP4发生变化，而与之无关的CP0、CP3、CP5 无变化。**

![](ECC校验【转载】.assets\23495115-d4d497a2359142bf.png)

ECC执行时，将从OOB区中读出的**原ECC校验和新ECC校验和按位异或**，有以下几种结果：

**①.全为0**，则表示不存在错（或是出现了 ECC无法检测的错误）；

**②.1个比特位为1**，表示 OOB区出错；

**③.11个比特位为1**，表示存在一个比特错误，且可纠正；

**④.其他情况**均表示出现了无法纠正的错误。

## **总结**

自此，我们归纳ECC能够用较小的校验场实现纠错的原因：

①.校验场更小是因为对1024比特做了异或处理，仅用1比特进行奇偶校验；

②.能够确保是数据场位翻转而非校验场位翻转，是因为校验场数据具有典型特征，可以首先对校验场是否发生翻转做判断。

