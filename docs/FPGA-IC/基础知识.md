* 超前进位加法器
通过逻辑运算的方式将各级的进位转化为只与当前级的输入以及最低位的进位c0有关，消除了各级之间进位级联的依赖性，降低了串行进位的延迟。假设二进制加法器的第i位输入位ai，bi，输出为si，进位输入为ci，进位输出为ci+1，则有
```si = ai^bi^ci```
```ci+1 = ai&bi + ai&ci + bi&ci = ai&bi + ci&(ai+bi)```
令```gi = ai$bi, pi = ai + bi```
则```ci+1 = gi + pi&ci```
将ci进一步拆解可得到进位输出ci+1仅与前面各级的输入ai,bi以及第一级的进位输入c0有关。
* 减法器
减法器的实现类似于加法器，通过逻辑表达式实现半减器，全减器。
最终应用实际上是通过真值表重拍后的全加器对某些输入数据去补来实现全减器。从而全加器和全减器的主体结构一致
* 比较器
A>B 或者A<B 的比较器逻辑其实相同，只是AB位置的差别，个人理解比较器和减法器实现类似，只是比较器只需要判断符号位，主要计算的是每一位的进位，每一位的最终结果可以忽略（能够节省一点面积，但是很有限），而减法器则需要准确的计算出每一位的值，另外A>=B和A<=B，相当于A>B 或者A<B 来说会多一些相等的判断，会多一点逻辑，但相对于减法器来说都会下，只是小的比较少。
* 乘法器
乘法器实质上由更基本的加法器组成。乘法运算的本质是部分乘积移位求和的过程，可通过全加器实现。
* 状态机
moore 型：输出只与当前状态有关
mealy 型：输出不仅与当前状态有关，还与当前输入有关
状态转移图->状态转移函数（卡诺图，由CS求NS）->输出函数（卡诺图，由CS求输出）
* Verilog
1. ===，case equality，其**返回结果只为0或1**
==，equality，其返回结果可以为0、1和x，只要条件中存在x或者z，则返回结果就是x。当返回结果为x时，不会进到true的分支
=== 和 !== 连同 x z一起判断，其**返回结果只为0或1**，对于未知的逻辑输出结果，只能为x，不会输出z。如 1 ^ z = x
2.  `>>> <<<` 表示算数移位，高位补符号位
3. **有操作数为无符号，则结果为无符号，除非操作数均为有符号，结果才为有符号**
4. Verilog 允许用户自己定义原语（user-defined primitives，UDP），例化和基本门的例化相同
5. casex，将x z值看作无关位，casez，将z看作无关位
6. automatic 用于声明一个自动的任务或函数，表示该任务或函数可重用的，用于动态分配每一个并发执行的任务或函数入口，没有该关键字则表示静态的
7. disable 用于禁止命名的块和任务
8. Verilog中还有许多没有用到过的语法，但是感觉这些语法使用SV更加方便
* 时序路径
源时钟路径：起始于源点（如一个输入端口）的源时钟，结束于发出时序单元的时钟引脚
* 数据路径
一般而言，都是从上一个寄存器的时钟端到下一个寄存器的输入端
* 目的时钟路径
起始于源点（如一个输入端口）的目的时钟，结束于用于正在捕获的时序单元时钟引脚
* 建立时间保持时间
建立时间裕量：data_require_time - data_arrival_time
```Tsu_slack = (T + Tclk2 - Tsu) - (Tco + Tlogic + Tclk1) - Tuncertain```
保持时间裕量：撤除数据的时间 - 数据所要求的保持时间
```Thd_slack = (Tco + Tlogic + Tclk1) - (Tclk2 + Thd) - Tuncertain```
建立时间违例一般是因为逻辑级数太多，或者扇出太大，布线太长。
保持时间违例是逻辑延迟太少，时钟skew太大，或者时钟jitter过大。
无论是建立时间还是保持时间，skew和jitter都会导致时序裕量变小，只是skew对于建立时间和保持时间分析而言，reg1和reg2的时钟延时方向相反，好的时钟树就是为了避免skew过大。
* 异步时序
复位恢复时间，复位移除时间
恢复时间（Recovery Time）是指异步控制信号（如寄存器的异步清除和置位控制信号）在“下个时钟沿”来临之前变无效的最小时间长度。这个时间的意义是，如果保证不了这个最小恢复时间，也就是说这个异步控制信号的解除与“下个时钟沿”离得太近（但在这个时钟沿之前），没有给寄存器留有足够时间来恢复至正常状态，那么就不能保证“下个时钟沿”能正常作用，也就是说这个“时钟沿”可能会失效。
去除时间（Removal）是指异步控制信号（如寄存器的异步清除和置位控制信号）在“有效时钟沿”之后变无效的最小时间长度。这个时间的意义是，如果保证不了这个去除时间，也就是说这个异步控制信号的解除与“有效时钟沿”离得太近（但在这个时钟沿之后），那么就不能保证有效地屏蔽这个“时钟沿”，也就是说这个“时钟沿”可能会起作用。
* 锁存器
**锁存器（latch）：**是电平触发的存储单元，数据存储的动作（状态转换）取决于输入时钟（或者使能）信号的电平值，仅当锁存器处于使能状态时，输出才会随着数据输入发生变化。

  分为**普通锁存器**和**门控锁存器**，普通锁存器无控制信号，输出状态始终直接由输入决定。在实际的数字系统中，为了协调各部分的工作，往往需要有一个特定的控制信号去控制锁存器状态转换的时间，该类锁存器叫做门控锁存器，在控制信号无效时，输出保持不变，不随输入变换；当控制信号有效时，输出由输入决定，跟随输入变化。

![image](https://upload-images.jianshu.io/upload_images/23495115-71ead4c1f00ecb84?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image](https://upload-images.jianshu.io/upload_images/23495115-4b12d50a4f0da84e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 

①正是因为门控锁存器在控制信号有效的期间内，都可以接收输入信号，所以，激励信号的任何变化，都将直接引起锁存器输出状态的改变。这时输入信号若发生多次变化，输出状态也可能发生多次变化，这一现象称为锁存器的空翻。
②其次，当门控锁存器的控制信号有效时，锁存器就变成了一个组合电路，时序逻辑电路的模型就等效为两个各组合电路互为反馈的反馈系统，因此，系统有可能会因为瞬态特性不稳定而产生振荡现象（尤其是当出现环回时，振荡可能会很快，以前甚至会损坏芯片）。
#时钟
* 同相时钟
频率可以不同，但时钟跳变沿对齐
* 同源时钟
通常由一个PLL或者DLL产生，相位不需要相同，只要求相位固定（同一PLL输出的时钟不同频率经过的分频组合路径不同，但是相位差是固定的）
* 同时钟域时钟
既是同源时钟，还要求相位相同且频率相同
* 同步时钟
时钟频率成整数倍，且相位可预测
例如一个时钟输出到另一个芯片，再以相同的频率回到自己的芯片，因为无法确定时钟在芯片内部的latency，所以输出的时钟与输入的时钟算异步
一个时钟送到两个PLL，就算输出频率一致，一般也算是异步时钟，除非de-stew
* 异步时钟
无法判定两个时钟相位
异步时钟通常通过异步时钟组进行约束，对于某些时钟需要先创建```create_clock -name {} -period xxx [get_ports {}]```
``` set_clock_groups -asynchronous -group [get_clocks {}] -group [get_clocks {}]```来避免时序分析工具对异步电路进行时序分析，而异步电路的功能是否正确是需要设计来保证的，可以通过CDC check。

## 闪存
闪存是EEPROM的一种，属于非易失存储器。闪存采用的是MOS晶体管技术，特点是绝缘层中含有浮置栅极，用于存储电荷，写入前不带电荷表现为耗尽型，写入后为增强型。闪存根据写入方式的不同可分为NAND型和NOR型，NAND型写入需要高压，NOR型写入需要大电流。以NAND型为例，

## 钳位二极管
通过二极管的钳位作用（单向导通）将被钳端的电位强制拉向参考端，这就称之为钳位。
钳位与稳压的区别：钳位是将某点的电位进行限制，使其不大于（正）或者不小于（负）参考端的值，该点的电位是可变的，是利用二极管的正向导通特性来进行钳位。稳压是将某点的电位稳定在某个恒定的值，电位不可改变，是利用二极管的反向击穿特性来进行稳压。
## 逻辑深度
增大LUT输入能够减少逻辑深度，速度提升，但是资源利用率下降，面积增大
## 逻辑级数
一条路径上面的组合逻辑级数，一般情况下最好是保证设计的逻辑级数成一个正态分布的趋势，逻辑级数太大时序难以收敛，逻辑级数太小面积会有浪费。
## 与非门 或非门
上并下串 与非
上串下并 或非
与非门或非门都是通用逻辑门，因为他们可以通过逻辑实现其他任何逻辑门。但是相同逻辑下与非门的面积和逻辑复杂度更低，因此大多数情况下都使用与非门来作为通用的逻辑门。
## DSP48E1
25*18 有符号数  48位ACC，可拆分为4个12或2个24实现SIMD
## 低功耗相关
LSI动态功耗通用公式（**电压平方**，时钟频率，负载电容正比）
`Pdynamic = 0.5*V^2*fclk*ΣActivity(i)*Ci`
* 降低动态功耗方法：
1、在工艺映射阶段将活动率高的布线吸收到查找表内部
2、最小化工艺映射过程中的节点复制
3、在逻辑块内部实现活动率较高的布线
* CMOS电路动态功耗
Pdynamic 正比于 `Cload * Vdd^2*f*α`
门控时钟降低动态功耗（直接与上时钟难以控制时钟偏斜，一般将输出接到输入，在不工作时输出保持不变，避免反转）
Pstatic正比于`Ileak*Vdd*n`，n为晶体管数量
电源门控降低静态功耗（切换高低电压）
## if语句
if...else...; if...else...; 属于**无优先级的**判断语句
if...else if...else...; 属于**有优先级**的判断语句
上述貌似都是相对于IC设计而言的，在VIVADO中通过综合，查看综合后的结果发现其实都是具有优先级的，只不过优先级顺序不同。后面有机会可以采用DC综合下看看。
```
always@(*)
begin
/*无优先级if判断语句，相当于逻辑组合*/
  if(sel1) o = a;
  else if(sel2) o = b; 
  else if(sel3) o = c; 
  else if(sel4) o = d; 
  else o = 0; 
/*存在优先级if判断语句，最后一个if优先级最高*/
    o = 0;
    if(sel1) o = a;
    if(sel2) o = b;
    if(sel3) o = c;
    if(sel4) o = d;
end
```
![](基础知识.assets\23495115-8d4b15ea0fbbd9cd.png)
![](基础知识.assets\23495115-073a2bf98cd43bf8.png)
