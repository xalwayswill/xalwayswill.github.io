## 理论
Exp-Golomb 编码，数据值越大，压缩率越高，数据值如果太小的话反而会增大数据位宽，此时应该传输未压缩的数据
一个码字的信息量，称为熵，二进制上可用log2(n)来表示数据的有效bit数，哥伦布编码采用加0前缀的方式，用来表示码字的信息量。指数哥伦布编码的比特串分为前缀和后缀两部分，[Mzero][1][INFO]，编码后码长为2M+1+k，M为前缀长度，M+k为后缀长度。M=zeroPrefixLength=floor(log2(codeNum+2^k))
编码前缀prefix表示数据所在的范围，后缀suffix表示数据数据在该范围内的偏移量
## 实现方式
用来表示非负整数的k阶指数哥伦布码可用如下步骤生成：
（1）将数字以二进制形式写出(B)，去掉最低的k个比特(D)，之后加1 (A = B + 1)
（2）计算A的比特个数(C)，将此数减一，即是需要增加的前导零个数(Z = C -1)
	（这一步等于计算当前数据在哪个组内）
（3）将第一步中去掉的最低k个比特位补回比特串尾部 (ExpG = Z个0 + A + D)
	（组内的偏移地址）
等于将原始的n bit数据编码为m bit，数据越小编码效率越高
实际的cmodel的实现方式：
k阶哥伦布编码第i个组（从0开始）的长度为 2^(k+i)，逐个减去对应组的长度，当减到负值时，最终得到对应的组号i 和offset，offset的值肯定小于2^(k+i)，从而offset的位宽为 k+i ，则前缀部分代表组号的0的个数为i，加上1bit的标志位，得到总的编码后的数据位宽为 2i+k+1，其中 i = log2(codeNum+2^k)


RTL 实现
M = log2(pix + 2^k)
length = 2M+k+1   TODO: why
前导0个数 = m+k
offset = pix + 2^k - 2^(m+k)
