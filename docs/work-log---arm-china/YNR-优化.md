算法简介：YNR的窗口大小为13x13，先从内部5x5的窗口通过MeanFilter计算lum，也就是均值滤波去估计噪声，并且将mv信息带入，如果运动则noise\*nlm_motion_r，之后再在5x5的窗内寻找最大值和最小值，通过max-min得到contrast，然后通过曲线拟合，估计Freq。
13x13的窗内部进行nlm计算，block match的size为3x3，共计算11x11个3x3窗口的sad，然后根据SAD去查表（寄存器可配）获得每个match block 中心像素的权重，然后对每个中心像素进行加权平均

* 问题1：YNR中通过在13\*13的窗口内做nlm，在nlm之前会根据5\*5的窗做一个均值来获得噪声，之后获得的噪声会参与nlm运算，原来的代码是直接生成13\*13的窗口，然后截取5\*5的窗口，导致会对13\*13\*10的窗口打拍好多次。
优化思路：修改生成像素窗的模块，让5\*5的窗口提前出来，这样原来13\*13的窗口输出需要6行line delay以及6个pixel的delay，修改后5\*5的窗口只需要2个cycle的delay出来，相对于原设计节省4拍的打拍逻辑，节约4\*13\*13\*10个bit的reg。
* 问题2：YNR输入像素还有mv数据，为了保持mv与拼窗后的数据保持时序同步，对mv数据也写入到sram中进行拼窗，但是出来的数据mv窗口不用，只取中间像素的值，这样就造成了sram的浪费，例如对于4k(3840)的图像，共需要12行line buffer，mv共用了3840x12=46080bit的sram空间，但是实际需求只是要将mv delay6行，也就是只需要6行的line buffer即可，从而能够节约3840*6=23040bit的存储空间。
优化思路：将mv单独进行delay操作。
* 问题3：在5x5窗内寻找最大值和最小值，原来的方法无论是五级两输入比较器(12+6+3+2+1)*2=48还是sh的那个三输入最后要用到6级两输入比较的蠢方法，最后都要用到48个两输入比较器。因为既要找最大值，也要找最小值。
优化思路：通过先对25个数据两两比较，得到两个中的max和min，然后12个max加上剩下的那个去找最大值，12个min和剩下的那个去找最小值，两部分分别都要用到四级6+3+2+1=12个两输入，共计24个，在加上第一级的12个两输入比较器，总共只需要36个两输入比较器，能够节省12个两输入比较器。
* 优化结果
YNR原来版本面积大约179670 -> 171721 (TSMC16FCLL)
