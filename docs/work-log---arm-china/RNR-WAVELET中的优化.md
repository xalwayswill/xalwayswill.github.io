![](RNR-WAVELET中的优化.assets\23495115-bb52094d6ce3bc32.png)

如果第一个pixel是G，则将3\*4的数据窗口写入wavelet中，同时选择右边3\*3的窗口，wavelet输出格式应该是1t1p的，第一个pixel输出结果是输入窗口的win[0][0]，同时将后续的输出结果全部延后一拍。且valid是每个cycle都连续的。对于最后的pixel，不需要额外的计算，只需要输出上一个窗口计算的右侧结果（更新后的，直接将上一次更新后的窗口的右侧输出即可）。
如果第一个pixel不是G，则同样将3\*4的数据窗口写入wavelet中，同时选择左边的3\*3的窗口计算，wavelet的输出格式也是1t1p的。此时输出结果就选择处理后的结果即可，valid同样保持每个cycle连续
wavelet的输出结果不单是当前的pixel，还有需要写入FIFO中的数据win[1][0],win[1][1],win[2][0],win[2][1]。以及需要更新的win[x][2] win[x][3]的数据。对于最后的pixel，同样输出最后的3*4窗口的右侧像素（最后一个pixel是没有更新的，但是不考虑是否更新过，均把输入的窗口数据拿来输出就行）

NOTE：每次输入wavelet的窗口都是3*4的，根据第一个pixel的pattern类型去选择输出数据

有符号数的/2，RTL中为补码，正数右移一位就可以只取整数，负数的话直接右移会导致0.5向负无穷舍入（例如-9的补码右移一位为-5而不是-4）

算法原理：
小波变换，通过计算一个低频的均值和三个方向的高频信息，然后对三个高频信息进行软阈值压缩（软阈值硬阈值的区分可以类比软着陆硬着陆）
之所以需要判断当前行第一个pixel为RB还是G，是因为算法设计的只能处理如下所示的窗
R/B   G   R/B
G     R/B   G
R/B   G   R/B
然后分别对R/B 和 G进行小波运算，同时根据均值滤波的结果估计噪声，再根据梯度判断边界强度，根据噪声计算软阈值的门限，根据计算出来的边界强度判断使用软阈值处理之后的结果还是处理之前的，之后再对处理后的数据进行小波逆变换，得到去噪后的结果。因为算法为了使用3x3的窗实现良好的去噪效果，进行了IIR滤波的设计，每个pixel都需要使用到上一次计算的结果，所以让算法将算法改进为了一个窗口处理完之后输出两个pixel的算法，这样能将计算的周期增加到两个cycle，每次当前窗口处理完之后都会将边缘的8个pixel同步更新，同时将左上角第一行的两个pixel结果输出，将下面两行更新后的数据写入line buffer中（在最开始还没有win更新的时候，写入line buffer的是原始数据），当win开始更新后，写入的就是下面两行最左侧的数据。因为需要一边从line buffer读取像素窗，一边需要将更新后的窗口写入到line buffer，单口ram为了避免读写冲突，需要保证hblanking为偶数或者大于模块的行处理延时（9cycles）。

SRAM 1344x48

面积：13311.618  SRAM 8999


